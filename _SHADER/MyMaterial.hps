static float4x4 _FMatrixMVP = transpose( FMatrixMVP );
static float4x4 _FMatrixMV  = transpose( FMatrixMV  );
static float4x4 _IMatrixMV  = transpose( IMatrixMV  );

//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$【定数】

static const float Pi = 3.141592653589793;

static const float Pi2 = Pi * 2.0;

static const float P2i = Pi / 2.0;

//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$【設定】

SamplerState _SamplerState {};

//$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$【ルーチン】

float Pow2( float _X )
{
    return _X * _X;
}

float Roo2( float _X )
{
    return sqrt( _X );
}

float2 VectorToSky( float3 _Vector )
{
    float2 _Result;

    _Result.x = ( Pi - atan2( _Vector.z, _Vector.x ) ) / Pi2;
    _Result.y = acos( _Vector.y ) / Pi;

    return _Result;
}

float Fresnel( float3 _EyeVec, float3 _NorVec, float _RefI )
{
    float A = _RefI;
    float B = dot( _EyeVec, _NorVec );
    float C = Roo2( 1.0 - Pow2( A ) * ( 1.0 - Pow2( B ) ) );

    return pow( ( A * B - C ) / ( A * B + B ), 2.0 )
         + pow( ( A * C - C ) / ( A * C + B ), 2.0 );
}

//##############################################################################

struct TSenderP               //フラグメントの変数型
{
    float4 Scr :SV_Position;  //位置（スクリーン）
    float4 Pos :TEXCOORD0;    //位置（グローバル）
    float4 Nor :NORMAL;       //法線（グローバル）
    float4 Tex :TEXCOORD1;    //テクスチャ座標
};

struct TResultP               //ピクセルの変数型
{
    float4 Col :SV_Target;    //色
};

////////////////////////////////////////////////////////////////////////////////

TResultP MainP( TSenderP _Sender )
{
    TResultP _Result;

    float3 N = normalize( _Sender.Nor.xyz );                //表面法線（グローバル）
    float3 L = -_Light[0].Dir.xyz;                          //光源方向（グローバル）
    float3 E = normalize( _EyePos.xyz - _Sender.Pos.xyz );  //視点方向（グローバル）
    float3 H = normalize( L + E );                          //ハーフベクトル

    float3 T = _Texture.Sample( _SamplerState, _Sender.Tex.xy ).rgb;  //テクスチャ色

    float  D =      max( dot( L, N ), 0.0 );                //拡散反射項
    float  S = pow( max( dot( H, N ), 0.0 ), _SpecShiny );  //鏡面反射項

    _Result.Col.r = _EmisColor.r
                  + _AmbiColor.r * _DiffColor.r * T.r
                  + _Light[0].Col.r * ( _DiffColor.r * T.r * D + _SpecColor.r * S );
    _Result.Col.g = _EmisColor.g
                  + _AmbiColor.g * _DiffColor.g * T.g
                  + _Light[0].Col.g * ( _DiffColor.g * T.g * D + _SpecColor.g * S );
    _Result.Col.b = _EmisColor.b
                  + _AmbiColor.b * _DiffColor.b * T.b
                  + _Light[0].Col.b * ( _DiffColor.b * T.b * D + _SpecColor.b * S );
    _Result.Col.a = 1;

    _Result.Col = _Opacity * _Result.Col;

    return _Result;
}

//##############################################################################